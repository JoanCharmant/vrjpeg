#region License
// 
// 2015 Joan Charmant
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetadataExtractor;
using MetadataExtractor.Formats.Jpeg;
using MetadataExtractor.Formats.Xmp;
using MetadataExtractor.IO;
using XmpCore;

namespace VrJpeg
{
  /// <summary>
  /// This class is a replacement to MetadataExtractor.JpegMetadataReader for Google *.vr.jpeg files.
  /// It does not attempt to read all the metadata though, only the XMP segments necessary to work 
  /// with these images as stereo-panoramas.
  /// If the parser succeeds the first directory will contain the basic metadata and the second one 
  /// will contain the extended metadata.
  /// 
  /// This class should also handle depth images generated by Lens Blur (Google camera app).
  /// </summary>
  public static class VrJpegMetadataReader
  {
    private const string XmpJpegPreamble = "http://ns.adobe.com/xap/1.0/\x0";
    private const string XmpJpegExtendedPreamble = "http://ns.adobe.com/xmp/extension/\x0";

    public static IReadOnlyList<XmpDirectory> ReadMetadata(string filename)
    {
      using (var stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read))
        return ReadMetadata(stream);
    }

    public static IReadOnlyList<XmpDirectory> ReadMetadata(Stream stream)
    {
      // This is a super-stripped-down version of JpegMetadataReader.Process() that only handles XMP data.
      
      var segmentType = JpegSegmentType.App1;
      var segmentData = JpegSegmentReader.ReadSegments(new SequentialStreamReader(stream), null);

      var segments = segmentData.GetSegments(segmentType);
      return ReadJpegSegments(segments);
    }

    private static IReadOnlyList<XmpDirectory> ReadJpegSegments(IEnumerable<byte[]> segments)
    {
      // This is a modified version of XmpReader.ReadJpegSegments
      // The original version specifically tests the buffer against the classic XMP preamble and discards everything else.
      // Here we also test against the extended XMP preamble and regroup all the extended segments into a single buffer.
      // Note that we do not import any of the usual tags as in ProcessXmpTags(). Users of the class have to go
      // through XmpMeta methods.

      var directories = new List<XmpDirectory>();
      byte[] extendedData = null;

      int maxPreambleLength = Math.Max(XmpJpegPreamble.Length, XmpJpegExtendedPreamble.Length);

      foreach (var segmentBytes in segments)
      {
        string extractedPreamble = Encoding.UTF8.GetString(segmentBytes, 0, maxPreambleLength);
        
        if (extractedPreamble.StartsWith(XmpJpegPreamble))
          ParseNormalXmpSegment(directories, segmentBytes);
        else if (extractedPreamble.StartsWith(XmpJpegExtendedPreamble))
          ParseExtendedXmpSegment(ref extendedData, segmentBytes);
      }
      
      if (extendedData == null)
        return directories;

      // We have collected extended XMP data, let's parse the reconstructed buffer.
      XmpDirectory directory = new XmpDirectory();
      try
      {
        var xmpMeta = XmpMetaFactory.ParseFromBuffer(extendedData);
        directory.SetXmpMeta(xmpMeta);
      }
      catch (XmpException e)
      {
        directory.AddError("Error processing XMP data: " + e.Message);
      }

      directories.Add(directory);
      return directories;
    }

    private static void ParseNormalXmpSegment(List<XmpDirectory> directories, byte[] segmentBytes)
    {
      byte[] xmpBytes = new byte[segmentBytes.Length - XmpJpegPreamble.Length];
      Array.Copy(segmentBytes, XmpJpegPreamble.Length, xmpBytes, 0, xmpBytes.Length);

      XmpDirectory directory = new XmpDirectory();
      try
      {
        var xmpMeta = XmpMetaFactory.ParseFromBuffer(xmpBytes);
        directory.SetXmpMeta(xmpMeta);
      }
      catch (XmpException e)
      {
        directory.AddError("Error processing XMP data: " + e.Message);
      }

      directories.Add(directory);
    }

    private static void ParseExtendedXmpSegment(ref byte[] extendedData, byte[] segmentBytes)
    {
      // Consolidate the current segment into the global buffer of the extended node.
      // Chunk data format is described in the XMP spec paragraph 2.1.3.1 "Extended XMP in JPEG".
      // http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf

      using (MemoryStream stream = new MemoryStream(segmentBytes))
      using (BinaryReader reader = new BinaryReader(stream))
      {
        byte[] preambleBytes = reader.ReadBytes(XmpJpegExtendedPreamble.Length);
        byte[] guidBytes = reader.ReadBytes(32);
        
        // FIXME: we should probably test if the GUID matches.

        uint totalSize = ReadUInt32(reader);
        uint destinationOffset = ReadUInt32(reader);

        if (extendedData == null)
          extendedData = new byte[totalSize];

        long sourceOffset = reader.BaseStream.Position;
        Array.Copy(segmentBytes, sourceOffset, extendedData, destinationOffset, segmentBytes.Length - sourceOffset);
      }
    }

    private static UInt32 ReadUInt32(BinaryReader reader)
    {
      byte[] bytes = reader.ReadBytes(4);
      
      if (BitConverter.IsLittleEndian)
        Array.Reverse(bytes);

      return BitConverter.ToUInt32(bytes, 0);
    }
  }
}
